---
layout: post
title: "📅 Spring 강의노트"
excerpt: " Spring 핵심 원리에 대한 강의 ① "
subtitle: "스프링 핵심 원리 - 기본편"
toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
date: 2022-2-25
tags: [Spring]
---

### About Spring 

- JPA:  DB 테이블과 자바 객체 사이의 매핑을 처리해주는 ORM 기술의 표준   
- Hibernate - JPA 프로바이더의 한 종류, Node의 sequelize와 동일
  
#### JPA의 특징

  - SQL 생성
  - 객체를 통해 쿼리를 자성할 수 있는 JPQL 지원
  - 성능 향상을 위한 몇가지 기법 제공 

  - Spring & JPA가 가장 main 기술임 

#### Spring: 여러가지 기술의 모음  

  - rest: 스프링 DI 컨테이너, AOP 이벤트, 기타
  - 웹 기술: 스프링 MVC, WebFlux  
  - 문맥에 따라 단어가 다르게 사용
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크 자체
    - 스프링 부트, 프레임워크 등을 모두 포함한 생태계를 지칭
  
#### Spring boot: 스프링을 편리하게 사용할 수 있도록 지원 

  - 단독으로 실핼할 수 있는 스프링 app을 쉽게 생성
  - 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 3rd 라이브러리 자동 구성 
  - 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능 제공 
  - 관례에 의한 간결한 설정 
  - 스프링 프레임워크를 이용하기 쉽게 도와주는 역할

#### 핵심 개념

  사용법만 안다고 해당 스택을 완벽하게 이해했다고 볼 수 없음. 핵심 개념에 대해서 알아야 함
  - 왜 만들었는가? 핵심 컨셉은?
  - 좋은 객체 지향 app을 개발할 수 있게 도와주는 프레임워크

### 좋은 객체 지향 특징?

  > 컴퓨터를 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하는 것

  - 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용
  - **역할**과 **구현**으로 구분하여 세상을 단순화시킴 (ex. 운전자 - 자동차, 공연무대, 정렬 알고리즘, 할인 정책 로직 등등)
  - 클라이언트는 내부 구조를 몰라도 되며 인터페이스(대상의 역할)만 알면 됨. 또한 구현 대상 자체를 변경해도 영향을 받지 않음
  - 객체 설계 시 상대적으로 중요한 역할(interface)를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

#### 다형성의 본질

  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능 -> 클라이언트를 변경 X, 서버의 구현 기능을 유연하게 변경 가능
  - 가장 변경이 없는 방향으로 인터페이스를 설계하는 것이 제일 중요

#### 스프링과 객체 지향  

  - 스프링은 **다형성**을 극대화해서 이용할 수 있게 도와줌 
  - 하지만 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발 불가 (OCP, DIP X)
  - 제어의 역전, 의존관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원  
  
### SOLID: 좋은 객체 지향 설계의 5가지 원칙

  - SRP 단일 책임 원칙 (Single Responsibility Principle): 하나의 클래스는 하나의 책임만 가짐, 하나의 책임이라는 것은 모호할 수 있음.
다시 말해 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 ex) UI 변경, 객체의 생성과 사용을 분리  
  
  - OCP 개방-폐쇄 법칙 (Open/Closed Principle): 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀(필요없다) 있어야 함. 인터페이스를 구현한 
새로운 클래스를 하나 만들어서 새로운 기능을 구현하는 방법으로 변경을 대체, 사용 영역과 객체를 생성하고 구성하는 영역 두가지로 분리

    ```java
    public class MemberService { // MemberService 클라이언트가 구현 클래스를 직접 선택
        private MemberRepository memberRepository = new MemoryMemberrepository(); // 기존 코드
    }
    
    public class MemberService {
        private MemberRepository memberRepository = new jdbcMemberrepository(); // 변경 코드
    }
    // 클라이언트 코드를 변경해야하며, 다형성을 사용했지만 
    ```

  - LSP 리스코프 치환 원칙 (Liskov Substitution principle): 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 
바꿀 수 있어야 함. ex) 엑셀은 후진이 아니라 전진 기능만 담당하는 역할  
      
  - ISP 인터페이스 분리 원칙 (Interface Segregation Principle): 특정 클라이언트를 위한 다수의 인터페이스가 범용 인터페이스 하나보다 낫다.
ex) 자동차 인터페이스를 운전 및 정비 인터페이스로 나누고, 사용자 클라이언트를 운전자 및 정비사 클라이언트로 나누면 정비 인터페이스 자체가 변해도 운전자
클라이언트에 영향을 주지 않음. -> 인터페이스가 명확해지고 대체 가능성이 높아짐  
    
  - DIP 의존관계 역전 원칙 (Dependency inversion principle): 구현 클래스에 의존하지 말고, 인터페이스에 의존(=역할)에 의존해야 함 
  ex) 쉐보레가 아니라 자동차 역할에 대해서 중요하게 여길 것


### 객체 지향 설계와 스프링 

  - Spring DI container: 
  - 모든 설계에 인터페이스를 부여하는 방향으로 설계

  - 인터페이스를 남발하면 '추상화'라는 비용이 발생 -> 코드를 다시 뜯어봐야하는 비용
  - 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링해서 인터페이스를 도입

### 관심사의 분리 

  - Spring을 하나의 공연으로 비유: 인터페이스(역할), Sasha(남주, 구현체), Lisa(여주, 구현체) 
    - 배우는 본인의 역할인 배역을 수행하는 것에만 집중  
    - Sasha는 어떤 여주가 선택되더라도 똑같이 공연할 수 있어야함  
    - 공연 구성, 담당배우 섭외, 배우 지정 책임을 담당하는 별도의 공연 기획자 필요  
    - 공연 기획자를 만들고, 배우와 공연 기획자의 책임을 확실히 분리   

    - AppConfig (공연 기획자): 구현 객체의 **생성**과 **연결**을 담당, Sasha나 Lisa 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것 
    같다고 해서 Dependency Injection (의존성 주입)이라고 부름

### IoC, DI 그리고 컨테이너

  - Inversion of Control(제어의 역전): 프로그램 흐름에 대한 제어를 AppConfig가 가져감  
  ※ 내가 작성한 코드를 제어하고 대신 실행하면 '프레임워크', 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 '라이브러리'

  - Dependency Injection: 
    - 정적인 클래스 의존관계: import 코드만 보고 의존 관계 쉽게 판단 가능
    - 동적인 객체(인스턴스) 의존 관계: **app 실행 시점**에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제
    의존 관계가 연결
    - DI 이용시, 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경가능. 뿐만 아니라, 정적인 클래스 의존관계를 
    변경하지 않고 인스턴스 의존관계 쉽게 변경 가능
    
  - IcC 컨테이너, **DI 컨테이너**: AppConfig처럼 객체 생성/관리 의존관계 연결해주는 것을 지칭. assembler 혹은 object factory라고도 함

